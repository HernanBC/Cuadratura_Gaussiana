{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>A continuaci\u00f3n se muestra la documentaci\u00f3n y una serie de ejemplos para la integraci\u00f3n utilizando cuadratura gaussiana por medio de  polinomios de Legrende, junto a sus respectivos ejemplos y el c\u00f3digo fuente de la implementaci\u00f3n en python.</p> <p>La cuadratura gaussina es un m\u00e9todo aproximado para resolver integrales que permite obtener gran precisi\u00f3n respecto a otros m\u00e9todos num\u00e9ricos.</p>"},{"location":"#contenido","title":"Contenido","text":"<ul> <li> <p>Referencia</p> </li> <li> <p>Cuadratura Gaussiana</p> </li> <li> <p>Tutorial</p> </li> </ul>"},{"location":"explanation/","title":"Cuadratura Gaussiana","text":""},{"location":"explanation/#descripcion-de-metodo-numerico","title":"Descripci\u00f3n de m\u00e9todo num\u00e9rico","text":"<p>Uno de los m\u00e9todos m\u00e1s poderosos para evaluar integrales de forma num\u00e9rica es la cuadratura Gaussiana.</p> <p>En esta clase vamos a discutir los resultados m\u00e1s importantes y c\u00f3mo aplicar la idea de cuadraturas para resolver integrales.</p> <p>Para derivaciones de resultados ver: Computational Physics - Mark Newman Cap\u00edtulo 5 y Ap\u00e9ndice C.</p> <p>La idea principal est\u00e1 dada por \\begin{align} \\int_a^b {\\rm{d}}x f(x) \\approx \\sum_{k=1}^{N+1} w_k f(x_k). \\end{align} donde:</p> <ul> <li>\\(w_k\\) son los \"pesos\"</li> <li>\\(x_k\\) son los puntos de muestreo. N\u00f3tese que usamos \\(N+1\\) puntos (es decir, \\(N\\) subregiones o subintervalos)</li> </ul> <p>Para la cuadratura Gaussiana:</p> <ul> <li>Los puntos de muestreo se escogen de manera tal que no son equidistantes. Esto introduce m\u00e1s grados de libertad para la misma discretizaci\u00f3n en \\(N\\) subregiones.</li> <li>Es exacta para un polinomio de orden \\((2N - 1)\\).</li> <li>Es decir, la cuadratura Gaussiana da la misma precisi\u00f3n que un polinomio de orden \\((2N - 1)\\).</li> </ul> <p>No vamos a probar el siguiente resultado (ver Ap\u00e9ndice C de Newman - Computational Physics), pero de manera muy interesante, existe una regla universal para escoger \\(w_k\\) y \\(x_k\\). Los pesos y puntos de muestreo se eligen tal que:</p> <ul> <li>\\(x_k\\) corresponden a las \\(N\\) ra\u00edces (ceros) de los polinomios de Legendre \\(P_N(x)\\) de orden \\(N\\).</li> <li>Los pesos se eligen tal que: \\(\\displaystyle w_k = \\left[\\frac{2}{1-x^2}\\left(\\frac{dP_N}{dx}\\right)^{-2}\\right]_{x={x_k}}\\), con \\(x_k\\) que cumple \\(P_N(x_k)=0\\)</li> </ul> <p>Hablemos de los pros y los contras del uso de cuadraturas Gaussianas para evaluar integrales.</p> <p>Pros:</p> <ul> <li>La ecuaci\u00f3n para evaluar los errores es muy complicada. Sin embargo, la aproximaci\u00f3n mejora con un error que decrece por un factor \\({\\rm{const.}} / N^2\\) cuando se incrementa el n\u00famero de subregiones de discretizaci\u00f3n en uno.</li> <li>Ejemplo: Pasar de \\(N=10\\) a \\(N=11\\), mejora el resultado de la estimaci\u00f3n por un factor de \\(\\approx 100\\). Esto indica que la convergencia ocurre con muy pocos puntos de muestreo.</li> </ul> <p>Cons:</p> <ul> <li>S\u00f3lo funciona bien si la funci\u00f3n a integrar es relativamente bien comportada. Si no lo es, se requiren m\u00e1s puntos de muestreo cerca de las regiones problem\u00e1ticas.</li> <li>Es muy complicado evaluar el error de manera precisa si lo necesitamos.</li> </ul>"},{"location":"explanation/#polinomios-de-legendre","title":"Polinomios de Legendre","text":"<p>Los polinomios de Legendre son un sistema de polinomios ortogonales que pueden ser definidos de manera recursiva. Tenemos: \\begin{align} \\forall (M, N) \\in\\mathbb N^2, \\quad \\int_{-1}^1 {\\rm{d}}x P_N(x)P_M(x) = \\frac{2\\delta_{MN}}{2N+1}. \\end{align} Note que los polinomios est\u00e1n definidos en el intervalo \\([-1, 1]\\). Los se definen empezando con \\begin{align} P_0(x) = 1 \\Rightarrow P_1(x) = x, \\end{align} tal que los siguientes \u00f3rdenes se generan con la regla de recursividad \\begin{align} (N+1)P_{N+1}(x) = (2N+1)xP_N(x) -NP_{N-1}(x). \\end{align} Alternativamente, los polinomios pueden ser definidos de manera iterativa bajo la regla (f\u00f3rmula de Rodrigues) \\begin{align} P_N(x) = \\frac1{2^N N!}\\frac{d^N}{dx^N}\\left[(x^2-1)^N\\right]. \\end{align}</p>"},{"location":"reference/","title":"Referencia","text":""},{"location":"reference/#Cuadratura.cuadrature.gaussxw","title":"<code>gaussxw(N)</code>","text":"<p>Calcula los puntos de muestreo y los pesos de la cuadratura de Gauss.</p> <p>La cuadratura de Gauss se utiliza para aproximar integrales definidas mediante una suma ponderada de valores de la funci\u00f3n en puntos espec\u00edficos.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>N\u00famero de puntos de muestreo y pesos a calcular, corresponde al n\u00famero de subregiones a usar.</p> required <p>Returns:</p> Name Type Description <code>Output</code> <code>tuple</code> <p>x (numpy.ndarray): Puntos de muestreo de la cuadratura de Gauss. w (numpy.ndarray): Pesos correspondientes a cada punto de muestreo.</p> <pre><code>Example:\n        &gt;&gt;&gt; x, w = gaussxw(5)\n        &gt;&gt;&gt; print(x)\n        &gt;&gt;&gt; print(w)\n</code></pre> Source code in <code>Cuadratura/cuadrature.py</code> <pre><code>def gaussxw(N):\n\n\t\"\"\"\n    Calcula los puntos de muestreo y los pesos de la cuadratura de Gauss.\n\n    La cuadratura de Gauss se utiliza para aproximar integrales definidas\n    mediante una suma ponderada de valores de la funci\u00f3n en puntos espec\u00edficos.\n\n    Args:\n\t\tN (int): N\u00famero de puntos de muestreo y pesos a calcular, corresponde al n\u00famero de subregiones a usar.\n\n    Returns:\n\t\tOutput (tuple):\n\t\t\tx (numpy.ndarray): Puntos de muestreo de la cuadratura de Gauss.\n\t\t\tw (numpy.ndarray): Pesos correspondientes a cada punto de muestreo.\n\n\tExample:\n\t\t&gt;&gt;&gt; x, w = gaussxw(5)\n\t\t&gt;&gt;&gt; print(x)\n\t\t&gt;&gt;&gt; print(w)\n    \"\"\"\n\n\t# SE OPTA POR MANTENER LA RUTINA TAL Y COMO SE ENCUENTRA EN EL JUPYTER ORIGINAL.\n\t# Aproximaci\u00f3n inicial\n\ta = np.linspace(3, 4 * (N - 1), N) / ((4 * N) + 2)\n\t# Note c\u00f3digo vectorial aqu\u00ed\n\tx = np.cos(np.pi * a + 1 / (8 * N * N * np.tan(a)))\n\n\t# Ahora calculamos las ra\u00edces de los polinomios utilizando el m\u00e9todo de Newton\n\t# Este es un tema que veremos la pr\u00f3xima semana!\n\t# De momento, puede ignorar el siguiente flujo de control con el \"while\" y saber que esto \n\t# devuelve los puntos de muestreo obtenidos con los polinomios de Legendre\n\tepsilon = 1e-15\n\tdelta = 1.0\n\twhile delta &gt; epsilon:\n\t\tp0 = np.ones(N, dtype = float)\n\t\t# Deep copy\n\t\tp1 = np.copy(x)\n\t\tfor k in range(1, N):\n\t\t\tp0, p1 = p1, ((2 * k + 1) * x * p1 - k * p0) / (k + 1)\n\t\tdp = (N + 1) * (p0 - x * p1) / (1 - x * x)\n\t\tdx = p1 / dp\n\t\tx -= dx\n\t\tdelta = np.max(np.abs(dx))\n\n\t# Ahora calculamos los pesos\n\tw = 2 * (N + 1) * (N + 1)/(N * N * (1 - x * x) * dp * dp)\n\n\t# Note que la funci\u00f3n devuelve un tuple\n\treturn x,w\n</code></pre>"},{"location":"reference/#Cuadratura.cuadrature.gaussxwab","title":"<code>gaussxwab(a, b, x, w)</code>","text":"<p>Transforma los puntos y pesos de la cuadratura de Gauss desde el intervalo [-1, 1] al intervalo [a, b].</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>L\u00edmite inferior del nuevo intervalo de integraci\u00f3n.</p> required <code>b</code> <code>float</code> <p>L\u00edmite superior del nuevo intervalo de integraci\u00f3n.</p> required <code>x</code> <code>ndarray</code> <p>Puntos de muestreo en el intervalo [-1, 1].</p> required <code>w</code> <code>ndarray</code> <p>Pesos asociados a los puntos de muestreo en [-1, 1].</p> required <p>Returns:</p> Name Type Description <code>Output</code> <code>tuple</code> <p>x_escalado (numpy.ndarray): Puntos de muestreo transformados al intervalo [a, b]. w_escalado (numpy.ndarray): Pesos transformados correspondientes a los nuevos puntos de muestreo en el intervalo [a, b].</p> <pre><code>Example:\n        &gt;&gt;&gt; x_escalado, w_escalado = gaussxw(1,3,x,w)\n        &gt;&gt;&gt; print(x_escalado)\n        &gt;&gt;&gt; print(w_escalado)\n</code></pre> Source code in <code>Cuadratura/cuadrature.py</code> <pre><code>def gaussxwab(a, b, x, w):\n\t\"\"\"\n    Transforma los puntos y pesos de la cuadratura de Gauss\n    desde el intervalo [-1, 1] al intervalo [a, b].\n\n    Args:\n\t\ta (float): L\u00edmite inferior del nuevo intervalo de integraci\u00f3n.\n\t\tb (float): L\u00edmite superior del nuevo intervalo de integraci\u00f3n.\n\t\tx (numpy.ndarray): Puntos de muestreo en el intervalo [-1, 1].\n\t\tw (numpy.ndarray): Pesos asociados a los puntos de muestreo en [-1, 1].\n\n    Returns:\n\t\tOutput (tuple):\n\t\t\tx_escalado (numpy.ndarray): Puntos de muestreo transformados al intervalo [a, b].\n\t\t\tw_escalado (numpy.ndarray): Pesos transformados correspondientes a los nuevos puntos de muestreo en el intervalo [a, b].\n\n\tExample:\n\t\t&gt;&gt;&gt; x_escalado, w_escalado = gaussxw(1,3,x,w)\n\t\t&gt;&gt;&gt; print(x_escalado)\n\t\t&gt;&gt;&gt; print(w_escalado)\n    \"\"\"\n\t# SE OPTA POR MANTENER LA RUTINA TAL Y COMO SE ENCUENTRA EN EL JUPYTER ORIGINAL.\n\t# Obtenido de pag 168 Newman)\n\t# Note que esta funci\u00f3n est\u00e1 escrita a-la-Pit\u00f3n: si funciona bueno; si no, es culpa suya.\n\treturn 0.5 * (b - a) * x + 0.5 * (b + a), 0.5 * (b - a) * w\n</code></pre>"},{"location":"reference/#Cuadratura.cuadrature.int_cuadraGauss","title":"<code>int_cuadraGauss(integrando, x_inf, x_sup, steps, noEscalado=gaussxw, escalado=gaussxwab)</code>","text":"<p>Calcula la integral de una funci\u00f3n utilizando la cuadratura de Gauss con polinomio ortogonal (Legendre).</p> <p>Esta funci\u00f3n eval\u00faa una integral definida en el intervalo [x_inf, x_sup] mediante la cuadratura de Gauss, escalando los puntos y pesos de la cuadratura  de Gauss mediante polinomios ortogonales al intervalo deseado. Por defecto se utiliza      polinomios de Legendre.</p> <p>Parameters:</p> Name Type Description Default <code>integrando</code> <code>callable</code> <p>Funci\u00f3n a integrar. Debe aceptar un array de puntos como entrada.</p> required <code>x_inf</code> <code>float</code> <p>L\u00edmite inferior del intervalo de integraci\u00f3n.</p> required <code>x_sup</code> <code>float</code> <p>L\u00edmite superior del intervalo de integraci\u00f3n.</p> required <code>steps</code> <code>int</code> <p>N\u00famero de puntos de muestreo a utilizar en la cuadratura.</p> required <code>noEscalado</code> <code>callable</code> <p>Funci\u00f3n que calcula los puntos y pesos en el intervalo [-1, 1]. Por defecto, utiliza <code>gaussxw</code>.</p> <code>gaussxw</code> <code>escalado</code> <code>callable</code> <p>Funci\u00f3n que transforma los puntos y pesos al intervalo [x_inf, x_sup]. Por defecto, utiliza <code>gaussxwab</code>.</p> <code>gaussxwab</code> <p>Returns:</p> Name Type Description <code>output</code> <code>float</code> <p>Aproximaci\u00f3n de la integral definida de <code>integrando</code> en el intervalo [x_inf, x_sup].</p> <pre><code>Example:\n        &gt;&gt;&gt; # Integrar x**6 -(x**2)*sin(2*x) en el intervalo [1,3]\n        &gt;&gt;&gt; def integrando(x):\n        &gt;&gt;&gt;             return x**6 -(x**2)*np.sin(2*x)\n\n        &gt;&gt;&gt; int_cuadraGauss(integrando,1,3)\n</code></pre> Source code in <code>Cuadratura/cuadrature.py</code> <pre><code>def int_cuadraGauss(integrando, x_inf, x_sup, steps, noEscalado = gaussxw, escalado = gaussxwab ):\n\t\"\"\"\n    Calcula la integral de una funci\u00f3n utilizando la cuadratura de Gauss con polinomio ortogonal (Legendre).\n\n    Esta funci\u00f3n eval\u00faa una integral definida en el intervalo [x_inf, x_sup]\n    mediante la cuadratura de Gauss, escalando los puntos y pesos de la cuadratura \n    de Gauss mediante polinomios ortogonales al intervalo deseado. Por defecto se utiliza \n\tpolinomios de Legendre.\n\n    Args:\n\t\tintegrando (callable): Funci\u00f3n a integrar. Debe aceptar un array de puntos como entrada.\n\t\tx_inf (float): L\u00edmite inferior del intervalo de integraci\u00f3n.\n\t\tx_sup (float): L\u00edmite superior del intervalo de integraci\u00f3n.\n\t\tsteps (int): N\u00famero de puntos de muestreo a utilizar en la cuadratura.\n\t\tnoEscalado (callable): Funci\u00f3n que calcula los puntos y pesos en el intervalo [-1, 1]. Por defecto, utiliza `gaussxw`.\n\t\tescalado (callable): Funci\u00f3n que transforma los puntos y pesos al intervalo [x_inf, x_sup]. Por defecto, utiliza `gaussxwab`.\n\n    Returns:\n\t\toutput (float): Aproximaci\u00f3n de la integral definida de `integrando` en el intervalo [x_inf, x_sup].\n\n\tExample:\n\t\t&gt;&gt;&gt; # Integrar x**6 -(x**2)*sin(2*x) en el intervalo [1,3]\n\t\t&gt;&gt;&gt; def integrando(x):\n\t\t&gt;&gt;&gt;\t\treturn x**6 -(x**2)*np.sin(2*x)\n\n\t\t&gt;&gt;&gt; int_cuadraGauss(integrando,1,3)\n    \"\"\"\n\n\tx_sin_escalar, w_sin_escalar = noEscalado(steps)\n\tx , w = escalado(x_inf,x_sup,x_sin_escalar,w_sin_escalar)\n\n\tI = np.dot(integrando(x),w)\n\treturn I\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Bajo esta implementaci\u00f3n, usar cuadratura de Gauss mediante polinomios de Legendre es bastante sencilla y se resume en definir la funci\u00f3n a integrar (<code>integrando</code>) y utilizar la funci\u00f3n <code>int_cuadraGauss</code> para obtener el resultado. A continuaci\u00f3n se explica con detalle cada paso:</p>"},{"location":"tutorial/#paso-1","title":"Paso 1:","text":""},{"location":"tutorial/#definir-la-funcion-a-integrar-y-sus-limites-de-integracion","title":"Definir la funci\u00f3n a integrar y sus l\u00edmites de integraci\u00f3n.","text":"<p>Por ejemplo, se desea integrar: \\(f(x) = x^6 - x^{2} sin(2x)\\) de \\([1,3]\\).</p> <pre><code>def integrando(x):\n    return x**6 -(x**2)*np.sin(2*x)\n</code></pre>"},{"location":"tutorial/#paso-2","title":"Paso 2:","text":""},{"location":"tutorial/#llamar-a-la-funcion-int_cuadragauss","title":"Llamar a la funci\u00f3n <code>int_cuadraGauss</code>.","text":"<pre><code>result = int_cuadraGauss(integrando, 1,3)\n</code></pre>"},{"location":"tutorial/#paso-3","title":"Paso 3:","text":""},{"location":"tutorial/#imprimir-el-resultado","title":"Imprimir el resultado.","text":"<pre><code>print(result)\n</code></pre>"}]}